///////////////////////////////////////////////////////////////
// reducefunc.cpp
// Author: Sean Cooke
// Professor: Scott Roueche
// Course: CSE 687 - Object Oriented Design
// Syracuse University
// Phase 2 - MapReduce
// Date: November 10, 2025
//
// Description:
//   This file defines the exported ReduceFunction for the MapReduce system.
//   The reducer reads an aggregated intermediate file containing <key, value> pairs
//   generated by the mapping and shuffling stages. It sums values associated
//   with identical keys and writes the final output to a single results file.
//
//   Upon successful completion, the reducer writes a "SUCCESS" marker file
//   to indicate that reduction was completed without error.
//
// Revision History:
//   10/28/2025 - Initial implementation
//   11/02/2025 - Added detailed logging, improved directory handling,
//                and added documentation comments
//   11/05/2025 - Implemented DLL export and dynamic linking compatibility
//   11/10/2025 - Final review and cleanup
///////////////////////////////////////////////////////////////

#include <string>
#include <unordered_map>
#include <fstream>
#include <sstream>
#include <iostream>
#include <filesystem>
#include <vector>

namespace fs = std::filesystem;

///////////////////////////////////////////////////////////////
// Function: ReduceFunction
//
// Purpose:
//   Perform the "Reduce" step of the MapReduce workflow.
//
//   The function accepts a path to an aggregated intermediate file that contains
//   all key-value pairs (e.g., <word, count>) emitted by mappers. The function
//   reads each line, parses the key and integer value, aggregates the counts
//   for identical keys, and writes the final reduced results to an output file.
//
// Parameters:
//   - aggregated_file: Full path to the aggregated intermediate file
//   - dummyVec:        Placeholder vector (not used, required for dynamic linking)
//
// Behavior:
//   1. Verifies the input file exists and can be opened.
//   2. Creates the output directory if it does not exist.
//   3. Reads each <key, value> line from the input file.
//   4. Accumulates integer counts in an unordered_map.
//   5. Writes results to "final_results.txt" in the output directory.
//   6. Creates a "SUCCESS" file to mark completion.
//
// Output:
//   - "final_results.txt" (aggregated key-value pairs)
//   - "SUCCESS" (empty file indicating reducer finished properly)
//
// Return:
//   void (results are written to files)
//
// Notes:
//   This function is exported from a DLL and called dynamically by the
//   MapReduce controller program.
//
///////////////////////////////////////////////////////////////

extern "C" __declspec(dllexport)
void ReduceFunction(const std::string& aggregated_file, const std::vector<int>& /*dummyVec*/)
{
    // Attempt to open the aggregated intermediate file
    std::ifstream input(aggregated_file);
    if (!input.is_open()) {
        std::cerr << "[ReduceDLL] Failed to open aggregated file: " << aggregated_file << "\n";
        return;
    }

    // Ensure the input file is not empty
    if (input.peek() == std::ifstream::traits_type::eof()) {
        std::cerr << "[ReduceDLL] Aggregated file is empty: " << aggregated_file << "\n";
        return;
    }

    // Define the output directory relative to the input file
    // Example: if aggregated_file = ./temp/intermediate.txt, output_dir = ./output
    fs::path output_dir = fs::absolute(fs::path(aggregated_file).parent_path() / "../output");
    if (!fs::exists(output_dir)) {
        fs::create_directories(output_dir);
    }

    // Define output file path for the final reduced results
    fs::path output_file = output_dir / "final_results.txt";
    std::ofstream output(output_file);
    if (!output.is_open()) {
        std::cerr << "[ReduceDLL] Failed to create output file: " << output_file << "\n";
        return;
    }

    // Container for storing the aggregated counts per key
    std::unordered_map<std::string, int> counts;
    std::string key;
    int value = 0;

    // Process each line: <key> <value>
    std::string line;
    while (std::getline(input, line)) {
        std::istringstream iss(line);
        if (!(iss >> key >> value)) {
            // Skip malformed lines
            continue;
        }
        counts[key] += value;
    }

    // Write final reduced results to the output file
    for (const auto& [k, v] : counts) {
        output << k << "\t" << v << "\n";
    }

    // Create a "SUCCESS" marker file to indicate completion
    fs::path success_file = output_dir / "SUCCESS";
    std::ofstream success(success_file);
    success.close();

    // Log completion status to console
    std::cout << "[ReduceDLL] Reduced output written to: " << output_file << std::endl;
}
